---
title: "Simulations of livestock resilience model with caspr"
author: "Florian D. Schneider"
date: "October 1st, 2015"
output: 
  rmarkdown::tufte_handout:
    fig_width: 6
    fig_height: 4
---


# The livestock resilience model

The model was designed as a simplification of our previously developed grazing model. Besides reflecting the mechanisms of positive local feedbacks, local facilitation and associational resistance, it also implements negative local feedbacks, such as competition and attractant-decoy effects.

It is a cellular automata model with cells that can take two possible cell states: occupied by vegetation (state: `1`) and unoccupied bare soil (state: `0`). Transition of cell states are defined as probabilities which are functions of the global cover $\rho_1$ (i.e. fraction of occupied cells) and the local cover $q_{1|1}$ (i.e. the proportion of occupied cells in the direct 4-cell neighborhood of the focal plant, i.e. an occupied cell). At each time step, these probabilities are evaluated against random numbers (i.e. the model is a probabilistic cellular automata) to see if a transition happens.  


## model definition 

Since there are two possible cell states, we have to define two probabilities of transition: the probability of **growth**, $w_{0,1}$, turning an empty cell into a vegetated, and the probability of **death**, $w_{0,1}$, removing vegetation from the cell.

For **plant mortality**, we combine the intrinsic mortality of plants, i.e. the inverse of their average livespan, $m$, and the additional rate of death due to livestock grazing. The latter results from the feeding rate of animals, $F$, times the livestock density, $L$. Feeding rate is modelled as a type III functional response, that is, a nonlinear function that saturates against a maximum feeding rate of a consumer with increasing resource density:

$$ F = \frac{a\rho_1^{q}}{1+ah\rho_1^{1+q}} $$

The feeding rate $F$  of one consumer depends on its search efficiency on the landscape, $a$, i.e. the area browsed in per timestep, as well as the handling time $h$ invested for ingesting and digesting, i.e. the time for removing one resource item from the population. For grazing this term can be interpreted as the time that it takes to consume the equivalent of one resource unit. This requires some detailed specification: ... 

The hill-coefficient $q$ defines the slowing down of feeding at very low resource cover. That can be due to several ecological processes such as resource accumulation (leading to a perceived dilution) or the occupation of inaccessible refuge areas (i.e. on inaccessible rocks). Since this definition overlaps somehow with other local interactions defined further below, it should be considered negligible for reasons of simplicity (i.e. $q = 0$).  

To implement spatially-explicit effects on grazing mortality, we add the mechanism of attractant decoy which is observed in nature. Grazers are attracted by plant patches and therefore the risk of suffering from grazing increases. We assume this attractivity enhances search efficiency, $a$, locally by the value $v$

$$ a = a^*  + v q_{1|1} $$



$$ w_{1,0} = m + \frac{aL\rho_1^{1+q}}{1+ah\rho_1^{1+q}} $$


    
$$ w_{0,1} = \frac{r \rho_1^{1+\alpha} b (1-\frac{\rho_1}{K})}{1-\rho_1} $$



## parameters

(More model details will follow)



# The caspr package

## Installation

Installation instructions and further information can be found on the package [repository website on Github](https://github.com/fdschneider/caspr) and the [package vignette](https://github.com/fdschneider/caspr/blob/master/vignettes/caspr.Rmd). 

In short, you only need a running version of R installed on your computer. All package dependencies will be installed automatically. Launch R and run: 

```{r, eval = FALSE}
install.packages("devtools")
devtools::install_github("fdschneider/caspr")
devtools::install_github("cascade-wp6/socialecological")
```

Then, once installed, you will have to call the library each time you start a new R session

```{r}
library(caspr)
library(socialecological)
```

## run simulations

The package is capable of running a couple of different models. For our project, I added the livestock resilience model to the package. You can review it's parameters and specifications by typing `?livestock`.

To run a model simulation, you have to provide an initial landscape object, i.e. a grid of cells that matches the specifications of the model. 

```{r, fig.width = 2, fig.height = 2, fig.marging = TRUE}
l <- init_landscape(states = c("1","0"), cover = c(0.2,0.8), width = 100)
par(mar = c(0,0,0,0))
plot(l)
```

The option `width` allows to increase or decrease the landscape size (now $100 x 100$ cells).
Then, you can start a simulation using the default parameters (returning a warning at the end of the simulation) with

```{r}
run <- ca(l, model = livestock, parms = livestock$parms)
plot(run)
summary(run)
```

The function `ca()` runs the simulation. This might take between 10 seconds and a couple of minutes, depending on your computer.

The `plot()` function plots the timeseries of the vegetation cover (cover of cell state "1") and the `summary()` function returns the mean cover of all potential cell states. 

Of course, you will want to modify the parameters (remember that `?livestock ` shows you the description of all parameters):

```{r}
pp <- livestock$parms
pp$b <- 0.1
pp$p <- 0.2
pp$L <- 12
run <- ca(l, model = livestock, parms = pp, t_max = 200)
plot(run)
```

`t_max` sets the maximal number of timesteps. More options for the function `ca()` are available by calling `?ca`. 

## access the simulation data

If you want to analyse the timeseries of vegetation cover you can extract it from the output object of the simulation, which is now stored in the R variable `run`.

For example you can access the parameters that were used to run the model by calling

```{r}
as.data.frame(run$model$parms)
```


You also can extract the vegetation cover for each single timestep and save it into an R object. To analyse variation over time, we usually would only look at a period before the end of the simulation. 

```{r}
t <- tail(run$time,100)
cover <- tail(run$cover[['1']], 100)

summary(cover)
```

There are further functions currently under development that allow to run a whole array of parameters. I will keep you updated about this. 

## contribute 

You always can check the current state of the development for the caspr package and report issues or bugs on the [GitHub issue tracker](https://github.com/fdschneider/caspr/issues).
